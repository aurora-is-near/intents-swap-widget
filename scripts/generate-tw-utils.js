// generate-utils.js
// Node 18+ recommended

import fs from 'fs';
import path from 'path';

const INPUT = path.resolve('./src/tailwind.css');
const OUTPUT = path.resolve('./dist/utils.css');

// Heuristics to pick which @theme custom properties become which utility families.
// We map normalized token names to their CSS var reference (var(--...)) and route them by prefix.
function main() {
  const css = fs.readFileSync(INPUT, 'utf8');

  // Extract the @theme block content
  const themeBlock = extractAtTheme(css);
  if (!themeBlock) {
    console.error('No @theme block found in input. Abort.');
    process.exit(1);
  }

  // Parse custom properties from @theme and :root
  const themeVars = parseCustomProps(themeBlock);
  const rootVars = parseCustomProps(extractRoot(css));

  // We only want variables defined in @theme that point to var(--sw-*)
  // because these represent public tokens (e.g., --color-sw-gray-300: var(--sw-gray-300))
  // Spacing tokens look like --spacing-sw-xxs: var(--sw-space-xxs)
  // Radii tokens look like --radius-sw-*: var(--sw-radius-*)
  const colorTokens = {};
  const spacingTokens = {};
  const radiusTokens = {};

  for (const [name, value] of Object.entries(themeVars)) {
    // Only accept values that are var(--something)
    const ref = getCssVarRef(value);
    if (!ref) continue;

    // Colors
    if (name.startsWith('--color-sw-')) {
      // tokenName example: sw-gray-300
      const tokenName = name.replace('--color-', '');
      colorTokens[tokenName] = `var(${ref})`;
      continue;
    }

    // Spacing
    if (name.startsWith('--spacing-sw-')) {
      const tokenName = name.replace('--spacing-', '');
      spacingTokens[tokenName] = `var(${ref})`;
      continue;
    }

    // Radius
    if (name.startsWith('--radius-sw-') || name === '--radius-full') {
      const tokenName = name.replace('--radius-', '');
      radiusTokens[tokenName] = `var(${ref})`;
      continue;
    }
  }

  // Also support direct radii in @theme that don’t point to var(), e.g., --radius-full: 99999px
  // We still want to emit var(--radius-full). So if value is not a var(...), keep as var(--name).
  for (const [name, value] of Object.entries(themeVars)) {
    if ((name.startsWith('--radius-sw-') || name === '--radius-full') && !getCssVarRef(value)) {
      const tokenName = name.replace('--radius-', '');
      radiusTokens[tokenName] = `var(${name})`;
    }
  }

  // Build CSS
  const out = [];
  out.push('/* FILE AUTO-GENERATED by generate-utils.js — do not edit by hand */\n');

  // Text/Background/Border/Fill/Stroke from colors
  out.push('@layer utilities {');
  for (const [token, varRef] of Object.entries(colorTokens)) {
    out.push(`  .text-${escapeClass(token)} { color: ${varRef}; }`);
    out.push(`  .bg-${escapeClass(token)} { background-color: ${varRef}; }`);
    out.push(`  .border-${escapeClass(token)} { border-color: ${varRef}; }`);
    out.push(`  .fill-${escapeClass(token)} { fill: ${varRef}; }`);
    out.push(`  .stroke-${escapeClass(token)} { stroke: ${varRef}; }`);
  }
  out.push('}\n');

  // Spacing: margin & padding shorthands
  out.push('@layer utilities {');
  for (const [token, varRef] of Object.entries(spacingTokens)) {
    // Gap
    out.push(`  .gap-${escapeClass(token)} { gap: ${varRef}; }`);

    // Margin
    out.push(`  .m-${escapeClass(token)} { margin: ${varRef}; }`);
    out.push(`  .mx-${escapeClass(token)} { margin-left: ${varRef}; margin-right: ${varRef}; }`);
    out.push(`  .my-${escapeClass(token)} { margin-top: ${varRef}; margin-bottom: ${varRef}; }`);
    out.push(`  .mt-${escapeClass(token)} { margin-top: ${varRef}; }`);
    out.push(`  .mr-${escapeClass(token)} { margin-right: ${varRef}; }`);
    out.push(`  .mb-${escapeClass(token)} { margin-bottom: ${varRef}; }`);
    out.push(`  .ml-${escapeClass(token)} { margin-left: ${varRef}; }`);

    // Padding
    out.push(`  .p-${escapeClass(token)} { padding: ${varRef}; }`);
    out.push(`  .px-${escapeClass(token)} { padding-left: ${varRef}; padding-right: ${varRef}; }`);
    out.push(`  .py-${escapeClass(token)} { padding-top: ${varRef}; padding-bottom: ${varRef}; }`);
    out.push(`  .pt-${escapeClass(token)} { padding-top: ${varRef}; }`);
    out.push(`  .pr-${escapeClass(token)} { padding-right: ${varRef}; }`);
    out.push(`  .pb-${escapeClass(token)} { padding-bottom: ${varRef}; }`);
    out.push(`  .pl-${escapeClass(token)} { padding-left: ${varRef}; }`);
  }
  out.push('}\n');

  // Radius: rounded-*
  out.push('@layer utilities {');
  for (const [token, varRef] of Object.entries(radiusTokens)) {
    out.push(`  .rounded-${escapeClass(token)} { border-radius: ${varRef}; }`);
    out.push(`  .rounded-t-${escapeClass(token)} { border-top-left-radius: ${varRef}; border-top-right-radius: ${varRef}; }`);
    out.push(`  .rounded-r-${escapeClass(token)} { border-top-right-radius: ${varRef}; border-bottom-right-radius: ${varRef}; }`);
    out.push(`  .rounded-b-${escapeClass(token)} { border-bottom-right-radius: ${varRef}; border-bottom-left-radius: ${varRef}; }`);
    out.push(`  .rounded-l-${escapeClass(token)} { border-top-left-radius: ${varRef}; border-bottom-left-radius: ${varRef}; }`);
    out.push(`  .rounded-tl-${escapeClass(token)} { border-top-left-radius: ${varRef}; }`);
    out.push(`  .rounded-tr-${escapeClass(token)} { border-top-right-radius: ${varRef}; }`);
    out.push(`  .rounded-br-${escapeClass(token)} { border-bottom-right-radius: ${varRef}; }`);
    out.push(`  .rounded-bl-${escapeClass(token)} { border-bottom-left-radius: ${varRef}; }`);
  }
  out.push('}\n');

  fs.writeFileSync(OUTPUT, out.join('\n'), 'utf8');
  console.log(`Generated ${OUTPUT}`);
}

function extractAtTheme(css) {
  const start = css.indexOf('@theme');
  if (start === -1) return '';
  // naive block extraction
  const braceStart = css.indexOf('{', start);
  if (braceStart === -1) return '';
  let i = braceStart + 1;
  let depth = 1;
  while (i < css.length && depth > 0) {
    if (css[i] === '{') depth++;
    else if (css[i] === '}') depth--;
    i++;
  }
  return css.slice(braceStart + 1, i - 1);
}

function extractRoot(css) {
  const rootIndex = css.indexOf(':root');
  if (rootIndex === -1) return '';
  const braceStart = css.indexOf('{', rootIndex);
  if (braceStart === -1) return '';
  let i = braceStart + 1;
  let depth = 1;
  while (i < css.length && depth > 0) {
    if (css[i] === '{') depth++;
    else if (css[i] === '}') depth--;
    i++;
  }
  return css.slice(braceStart + 1, i - 1);
}

function parseCustomProps(block) {
  const map = {};
  if (!block) return map;

  // Simple regex for lines like: --foo-bar: value;
  // Handles comments and whitespace. Not a full CSS parser, but robust enough for token blocks.
  const lines = block.split('\n');
  for (let raw of lines) {
    let line = raw.trim();
    if (!line || line.startsWith('/*')) continue;
    // strip inline comments
    line = line.replace(/\/\*.*?\*\//g, '').trim();
    const m = line.match(/^--[A-Za-z0-9-_]+:\s*[^;]+;/);
    if (!m) continue;
    const [full] = m;
    const idx = full.indexOf(':');
    const name = full.slice(0, idx).trim();
    const value = full.slice(idx + 1).trim().replace(/;$/, '');
    map[name] = value;
  }
  return map;
}

function getCssVarRef(value) {
  // Return the inner variable name if the value is var(--something), else null
  // Accepts values like: var(--sw-gray-300) or var(--sw-space-md)
  const m = value.match(/^var\(\s*(--[A-Za-z0-9-_]+)\s*\)$/);
  return m ? m[1] : null;
}

function escapeClass(token) {
  // Turn token like "sw-gray-300" or "sw-xxs" into a safe class fragment.
  // We assume tokens already contain only [A-Za-z0-9-_]. Escape leading digits if any.
  if (/^[0-9]/.test(token)) return `\\3${token} ${token.slice(1)}`;
  return token.replace(/[^A-Za-z0-9-_]/g, s => '\\' + s);
}

main();
